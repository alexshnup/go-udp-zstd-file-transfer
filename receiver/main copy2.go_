package main

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"fmt"
	"log"
	"net"
	"os"
	"strconv"
	"sync"
	"time"
)

const (
	port       = 30000
	outputPath = "output_file" // Replace with your output file path
	// receiveTimeout = 20 * time.Second // Timeout after 30 seconds of inactivity
)

var mutex sync.Mutex // Mutex for synchronizing access to receivedChunks

const numWorkers = 4 // Number of worker goroutines for processing data

func processChunksSlow(workerId int, chunksChan <-chan []byte, receivedChunks map[int][]byte, wg *sync.WaitGroup) {
	for packet := range chunksChan {
		// Extract sequence number and chunk data
		splitIndex := bytes.IndexByte(packet, ':')
		sequence, _ := strconv.Atoi(string(packet[:splitIndex]))
		chunkData := packet[splitIndex+1:]

		mutex.Lock()
		receivedChunks[sequence] = chunkData
		mutex.Unlock()
		// fmt.Printf("Worker %d received chunk %d\n", workerId, sequence+1)
		// wg.Done()
	}
}

func processChunks(workerId int, chunksChan <-chan []byte, receivedChunks map[int][]byte, mutex *sync.Mutex, wg *sync.WaitGroup) {
	for packet := range chunksChan {
		// Extract the sequence number directly from the first 4 bytes
		sequence := int(binary.BigEndian.Uint32(packet[:4]))

		// Extract the chunk data
		chunkData := packet[4:]

		mutex.Lock()
		receivedChunks[sequence] = chunkData
		mutex.Unlock()

		// wg.Done()
	}
}

func main() {

	// get local ip address
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		panic(err)
	}
	var localIP string
	for _, address := range addrs {
		// check the address type and if it is not a loopback the display it
		// = ipv4
		if ipnet, ok := address.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
			localIP = ipnet.IP.String()
			fmt.Println(localIP)
		}
	}

	addr, err := net.ResolveUDPAddr("udp", fmt.Sprintf(":%d", port))
	if err != nil {
		fmt.Println("Error resolving UDP address:", err)
		return
	}

	conn, err := net.ListenUDP("udp", addr)
	if err != nil {
		fmt.Println("Error listening on UDP:", err)
		return
	}
	defer conn.Close()

	file, err := os.Create(outputPath)
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close()

	writer := bufio.NewWriter(file)
	defer writer.Flush()

	totalChunksChan := make(chan int, 1) // Channel to receive totalChunksExpected
	receivedChunks := make(map[int][]byte)
	chunksChan := make(chan []byte, 100) // Buffered channel
	var wg sync.WaitGroup

	// Start worker goroutines
	for i := 0; i < numWorkers; i++ {
		fmt.Printf("start worker %d\n", i)
		go processChunks(i, chunksChan, receivedChunks, &mutex, &wg)
	}

	go func() {
		for {
			buffer := make([]byte, 2048) // Move buffer allocation here
			n, _, err := conn.ReadFromUDP(buffer)
			if err != nil {
				fmt.Println("Error reading UDP message:", err)
				return
			}

			if bytes.HasPrefix(buffer[:n], []byte("total:")) {
				totalChunksExpected, _ := strconv.Atoi(string(buffer[6:n]))
				// wg.Add(totalChunksExpected)
				totalChunksChan <- totalChunksExpected // Send totalChunksExpected to the main goroutine
				continue
			}

			chunksChan <- buffer[:n] // Send the data to be processed

		}
	}()

	// Wait for a bit to allow the receiver to start
	// time.Sleep(300 * time.Second)
	// input := bufio.NewScanner(os.Stdin)
	// input.Scan()
	// fmt.Println("Receiver started, waiting for data...")

	// 	// Main goroutine waits for all chunks or timeout
	// 	var sequence int
	// 	for len(receivedChunks) < totalChunksExpected {
	// 		select {
	// 		case <-newChunkChan:
	// 			// New chunk received, continue waiting
	// 			if sequence%10 == 0 {
	// 				log.Printf("\x1b[33m New chunk received  \x1b[35m %d \x1b[0m of \x1b[32m %d  \x1b[0m size= %d\n", sequence+1, totalChunksExpected, len(receivedChunks))
	// 			}
	// 			if sequence > totalChunksExpected-10 {
	// 				log.Printf("\x1b[33m New chunk received  \x1b[35m %d \x1b[0m of \x1b[32m %d  \x1b[0m size= %d\n", sequence+1, totalChunksExpected, len(receivedChunks))
	// 			}
	// 		case <-time.After(receiveTimeout):
	// 			fmt.Println("Timeout reached, stopping reception")
	// 			goto done
	// 		}
	// 		sequence++
	// 	}
	// done:

	totalChunksExpected := <-totalChunksChan
	fmt.Printf("Total chunks expected: %d\n", totalChunksExpected)

	// print size of map

	log.Println("Waiting for receiver to start...")
	prevSize := 0
	prevCount := 10
	for {
		log.Printf("\x1b[33m Size of map: \x1b[35m  %d \x1b[0m of %d\n", len(receivedChunks), totalChunksExpected)
		if len(receivedChunks) == totalChunksExpected {
			break
		}
		if len(receivedChunks) == prevSize {
			prevCount--
		}
		if prevCount == 0 {
			break
		}
		prevSize = len(receivedChunks)
		time.Sleep(1 * time.Second)
	}

	missedChunks := 0

	// Reassemble and write the file
	for i := 0; i < totalChunksExpected; i++ {
		if chunk, ok := receivedChunks[i]; ok {
			if totalChunksExpected > 10 && i%(totalChunksExpected/10) == 0 {
				log.Printf("\x1b[33m Writing chunk: \x1b[35m  %d \x1b[0m of %d\n", i+1, totalChunksExpected)
			}
			writer.Write(chunk)
		} else {
			missedChunks++
			// fmt.Printf("Missing chunk: %d of %d\n", i+1, totalChunksExpected)
		}
	}
	fmt.Printf("Missed chunks: %d\n", missedChunks)

	writer.Flush()
	fmt.Println("File reassembled")
}

// // waitTimeout waits for the WaitGroup for the specified max timeout.
// // Returns true if waiting timed out.
// func waitTimeout(wg *sync.WaitGroup, timeout time.Duration) bool {
// 	c := make(chan struct{})
// 	go func() {
// 		defer close(c)
// 		wg.Wait()
// 	}()
// 	select {
// 	case <-c:
// 		return false // Completed normally
// 	case <-time.After(timeout):
// 		return true // Timed out
// 	}
// }
